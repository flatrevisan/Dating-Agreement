//SPDX-License-Identifier: CC-BY-4.0
pragma solidity 0.6.10;

contract DatingAgreement 
{
    struct Lovers 
    {
        string name;
        address payable party;
        uint id;
    }
    
    address payable public lawyer;
    uint ids;
    
    mapping (uint => Lovers) hooked;
    
    event statusCommitment (address, statuses);
    event feesReceived (address, uint256, string);
    
    enum statuses {Single, Dating}
    statuses currentStatus;
    
    constructor () public
    {
        lawyer = 0x888cDa7b74D2364FfBA6c27FeFF2237501B85DF6;
        currentStatus = statuses.Single;
    }
    
    modifier onlyWhileUncommitted
    {
        require (currentStatus == statuses.Single, 'Currently in a committed relationship.');
        _;
    }
    
    modifier costs (uint _fee)
    {  
        require (msg.value >= _fee, "Not enough Ether provided for payment of Legal Fees!");
        _;
    }
    
    function identifyLovers  (string memory _name, address payable _party) payable public costs (1 ether)
   {
        _party = msg.sender;
        
        ids = ids+1;
        
        hooked [ids] = Lovers (_name, _party,ids);
    }
    
    function commit () payable public
    {
        for (uint i =1; i <= 2; i++)
            {
            currentStatus = statuses.Dating;
            msg.sender.transfer (msg.value);
            emit statusCommitment (msg.sender, currentStatus);
            }
    }
    
    function payFee () external payable
    {
        lawyer.transfer (address(this).balance);
        emit feesReceived (msg.sender, msg.value, "Legal Fees received. Thank You!");
    }    
    
    
    function confirmStatus () public view returns (address, address)
    {
        return hooked[1].party; 
        return hooked[2].party;
    }
    
    function commitFurther () payable public costs (1 ether) 
    {
        require (msg.value >= 1 ether, "Not enough Ether provided."); 
        require (currentStatus == statuses.Dating, "Already Committed.");
        
        for (uint i =1; i <= 2; i++)
            {
                Lovers memory hooked = hooked[1];
                hooked[1] = msg.sender;
            }
        currentStatus = statuses.CommonLawMarriage;
        msg.sender.transfer(msg.value);
        
    }
    
    
}
