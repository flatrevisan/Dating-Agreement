//SPDX-License-Identifier: CC-BY-4.0
pragma solidity 0.6.10;

contract RelationshipContract
{
    struct Lovers 
    {
        string name;
        address payable party;
    }
    
    address payable public lawyer;
    uint totalConsent;
    uint loversInvolved;
    
    Lovers [] public hooked;
    
    event consentDeclarationIssued (address, string);
    event statusCommitment (address, statuses);
    event changeStatusFailed (address,statuses);
    event feesReceived (address, uint256, string);
    
    enum statuses {Single, Dating, CommonLawMarriage}
    statuses currentStatus;
    
    constructor () public
    {
        lawyer = 0x888cDa7b74D2364FfBA6c27FeFF2237501B85DF6;
        currentStatus = statuses.Single;
        address _mainLover;
    }
    
    
    modifier minimumLovers ()
    {  
        require (loversInvolved >= 2, "Not enough Parties to the Contract");
        _;
    }
    
    function identifyLovers (string memory _name, address payable _party) public returns (bool) 
    {
        require(msg.sender == _mainLover, "Only one of the Parties is responsible for informing the other's name and address.");
        Lovers memory storeLovers = Lovers (_name, _party);
        hooked.push(storeLovers);
        hooked[_party]=true;
        loversInvolved = loversInvolved + 1;
        return true;
    }
    
    function denyLovers (string memory _name, address payable _party) public returns (bool) 
    {
        require(msg.sender == _mainLover, "Only one of the Parties is responsible for informing the other's name and address.");
        require(hooked[_party] == true, "Party not found");
        hooked[_party] = false;
        loversInvolved = loversInvolved - 1;
        return true;
    }
    
    function commitment (uint _consent1, uint _consent2) payable public minimumLovers
    {
        require (msg.sender == _mainLover || msg.sender == hooked[_party]);
        
        uint consent1;
        if (_consent1 == 1) 
        {
            consent1 = consent1 + 1;
            emit consentDeclarationIssued(msg.sender, "You just accepted the commitment to date!");
        } else if (_consent1 == 2) {
            consent1 = consent1 +0;
        }
        
        uint consent2;
        if (_consent2 == 1) 
        {
            consent2 = consent2 + 1;
            emit consentDeclarationIssued(msg.sender, "You just accepted a separate property marital property system.");
        } else if (_consent1 == 2) {
            consent1 = consent1 +0;
        }
        
        if (consent1 == loversInvolved || consent2 == loversInvolved)
        {
            currentStatus = statuses.Dating;
            msg.sender.transfer (msg.value);
            emit statusCommitment (msg.sender, currentStatus);
        } else { 
            emit changeStatusFailed (msg.sender, "No change of relationship status verified due to lack of consent."); 
        }
    }       
    
    function payFee () external payable
    {
        lawyer.transfer (address(this).balance);
        emit feesReceived (msg.sender, msg.value, "Legal Fees received. Thank You!");
    }    
    
    
    function confirmStatus () public view returns (Lovers)
    {
        return hooked[Lovers]; 
        return block.timestamp (uint);
        return currentStatus;
    }
    
    function commitFurther () payable public costs (1 ether) 
    {
        require (msg.value >= 1 ether, "Not enough Ether provided."); 
        require (currentStatus == statuses.Dating, "Already Committed.");
        
        for (uint i =1; i <= 2; i++)
            {
                Lovers memory hooked = hooked[1];
                hooked[1] = msg.sender;
            }
        currentStatus = statuses.CommonLawMarriage;
        msg.sender.transfer(msg.value);
        
    }
    
    
}
